import logging
import re
import subprocess

_logger = logging.getLogger(__name__)


class Instruction(object):

    address = None
    bytecode = None
    instruction = None
    args = None

    _hex_pattern = re.compile(r"(0x)?[0-9A-F]", re.IGNORECASE)

    @classmethod
    def from_match(cls, match):
        instr = cls()
        instr.address = int(match.group("address"), 16)
        instr.bytecode = match.group("bytecode")
        instr.instruction = match.group("instruction")
        instr.args = match.group("args")
        return instr

    @property
    def is_relative_call(self):
        return self.instruction == "call" and self._hex_pattern.fullmatch(self.args)

    @property
    def is_nop(self):
        return self.instruction == "nop"

    def __str__(self):
        return " ".join([self.address, self.bytecode, self.instruction, self.args])


def disassemble_file(filename: str) -> str:
    """
    Disassembles the given file with ndisasm/32-bit and
    annotates it with addresses being function entry points

    :param filename: Path to a ndisasm generated file with disassembly
    :returns: The file content, extended with function annotations
    """
    result = subprocess.run(
        ["ndisasm", "-b32", filename], capture_output=True, check=True
    )
    if result.returncode != 0:
        _logger.error(
            "Could not disassemble file '%s': %s",
            filename,
            result.stderr.decode("utf-8"),
        )
        return None
    return annonate_disassembly(result.stdout.decode("utf-8"))


def annonate_disassembly(disassembly):
    """
    Inserts lines which indicate the given next line in the disassembly is (probably) a function.
    This is detected by searching for call target addresses in the disassembly.

    :param disassembly: A string containing disassembly generated by ndisasm
    :returns: The given disassembly extented with annotations for functions
    """

    function_header = f"{'#'*24} Function {'#'*24}"
    output_lines = [function_header]
    pat = re.compile(r"(?P<addr>[0-9A-F]+)", re.IGNORECASE)
    call_targets = set(get_call_targets(disassembly).keys())
    for line in disassembly.split("\n"):
        match = pat.match(line)
        if match:
            addr = int(match.group("addr"), 16)
            if addr in call_targets:
                output_lines.append(function_header)
            output_lines.append(line)
    return "\n".join(output_lines)


_FILTER_WORDS = [
    "call",
    "jg",
    "jnz",
    "jmp",
    "jnc",
    "jnl",
    "jl",
    "jns",
    "js",
    "jng",
    "nop",
    "jz",
    "jna",
    "ja",
    "jae",
    "jb",
    "jbe",
    "jc",
    "jnae",
]


_NDISASM_LINE_PATTERN = re.compile(
    r"(?P<address>[0-9A-F]+)\s+(?P<bytecode>[0-9A-F]+)\s+(?P<instruction>\w+)(\s+(?P<args>.*))?",
    re.IGNORECASE,
)


def parse_disassembly(disassembly: str) -> list[dict[str, str]]:
    """
    Parses the given ndisasm disassembly into a list of dictionaries,
    containing instruction info read from each line.


    :param disassembly: A string containing the disassembly generated by ndisasm
    :returns: A list of Instruction objects

    """
    instructions = []
    for line in disassembly.split("\n"):
        match = _NDISASM_LINE_PATTERN.match(line)
        if match:
            instr = Instruction.from_match(match)
            instructions.append(instr)
    return instructions


def get_instruction_count(disassembly: str) -> dict[str, int]:
    """
    Counts the instructions in the given ndisasm disassembly, ignoring differences in arguments.

    :param disassembly: A string containing the disassembly generated by ndisasm
    :returns: A dictionary of instructions with their occurrence in the disassembly
    """
    instruction_count = {}
    for instr in parse_disassembly(disassembly):
        if not instr.is_nop:
            instruction_count[instr.instruction] = (
                instruction_count.get(instr.instruction, 0) + 1
            )
    return instruction_count


def get_call_targets(disassembly):
    targets = {}
    for instr in filter(lambda i: i.is_relative_call, parse_disassembly(disassembly)):
        dest = int(instr.args, 16)
        targets[dest] = targets.get(dest, 0) + 1
    return targets
